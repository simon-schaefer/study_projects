/*
 This is an interface for mpc_1_forces that can be used to call the solver generated by FORCES Pro
*/ 

#include "../include/mpc_1_forces.h"
#include "../include/internal_mpc_1_forces_1.h"
#include <stdio.h>

/* For Visual Studio 2015 Compatibility */
#if (_MSC_VER >= 1900)
FILE _iob[3];
FILE * __cdecl __iob_func(void)
{
    _iob[0] = *stdin;
    _iob[1] = *stdout;
    _iob[2] = *stderr;
    return _iob;
}
#endif

extern solver_int32_default mpc_1_forces_solve(mpc_1_forces_params *params, mpc_1_forces_output *output, mpc_1_forces_info *info, FILE *fs) 
{
	/* Some memory */
	internal_mpc_1_forces_1_params params_1;
	internal_mpc_1_forces_1_output output_1;
	internal_mpc_1_forces_1_info info_1;

	solver_int32_default exitflag;
	/* define variables */
	solver_int32_default i;
	/* SOLVER 1 --------------------------------------------------------*/
	/*Assigning parameter values of solver #1*/
	/*Assigning parameter values of solver #1*/
	params_1.p_1[0] = 0.000000000000000000;
	params_1.p_1[1] = 0.000000000000000000;
	params_1.p_1[2] = 0.000000000000000000;
	params_1.p_1[3] = (1.000000000000000000 * params->x0[0]);
	params_1.p_1[4] = (1.000000000000000000 * params->x0[1]);
	params_1.p_1[5] = (1.000000000000000000 * params->x0[2]);

	/* call solver #1 */
	exitflag = internal_mpc_1_forces_1_solve(&params_1, &output_1, &info_1, fs );

	/* iterations */
	info->it = info_1.it;

	/* iterations to optimality (branch and bound) */
	info->it2opt = info_1.it2opt;

	/* res_eq */
	info->res_eq = info_1.res_eq;

	/* res_ineq */
	info->res_ineq = info_1.res_ineq;

	/* pobj */
	info->pobj = info_1.pobj;

	/* dobj */
	info->dobj = info_1.dobj;

	/* dgap */
	info->dgap = info_1.dgap;

	/* rdgap */
	info->rdgap = info_1.rdgap;

	/* mu */
	info->mu = info_1.mu;

	/* mu_aff */
	info->mu_aff = info_1.mu_aff;

	/* sigma */
	info->sigma = info_1.sigma;

	/* lsit_aff */

	info->lsit_aff = info_1.lsit_aff;

	/* lsit_cc */
	info->lsit_cc = info_1.lsit_cc;

	/* step_aff */
	info->step_aff = info_1.step_aff;

	/* step_cc */
	info->step_cc = info_1.step_cc;

	/* solver time */
	info->solvetime = info_1.solvetime;


	/* OUTPUTS -----------------------------------------------------------*/
	/*Build outputs*/
	output->output1[0] = (1.000000000000000000 * output_1.o_1[0]);

	output->output1[1] = (1.000000000000000000 * output_1.o_2[0]);

	output->output1[2] = (1.000000000000000000 * output_1.o_3[0]);

	output->output1[3] = (1.000000000000000000 * output_1.o_4[0]);

	output->output1[4] = (1.000000000000000000 * output_1.o_5[0]);

	output->output1[5] = (1.000000000000000000 * output_1.o_6[0]);

	output->output1[6] = (1.000000000000000000 * output_1.o_7[0]);

	output->output1[7] = (1.000000000000000000 * output_1.o_8[0]);

	output->output1[8] = (1.000000000000000000 * output_1.o_9[0]);

	output->output1[9] = (1.000000000000000000 * output_1.o_10[0]);

	output->output1[10] = (1.000000000000000000 * output_1.o_11[0]);

	output->output1[11] = (1.000000000000000000 * output_1.o_12[0]);

	output->output1[12] = (1.000000000000000000 * output_1.o_13[0]);

	output->output1[13] = (1.000000000000000000 * output_1.o_14[0]);

	output->output1[14] = (1.000000000000000000 * output_1.o_15[0]);

	output->output1[15] = (1.000000000000000000 * output_1.o_16[0]);

	output->output1[16] = (1.000000000000000000 * output_1.o_17[0]);

	output->output1[17] = (1.000000000000000000 * output_1.o_18[0]);

	output->output1[18] = (1.000000000000000000 * output_1.o_19[0]);

	output->output1[19] = (1.000000000000000000 * output_1.o_20[0]);

	output->output1[20] = (1.000000000000000000 * output_1.o_21[0]);

	output->output1[21] = (1.000000000000000000 * output_1.o_22[0]);

	output->output1[22] = (1.000000000000000000 * output_1.o_23[0]);

	output->output1[23] = (1.000000000000000000 * output_1.o_24[0]);

	output->output1[24] = (1.000000000000000000 * output_1.o_25[0]);

	output->output1[25] = (1.000000000000000000 * output_1.o_26[0]);

	output->output1[26] = (1.000000000000000000 * output_1.o_27[0]);

	output->output1[27] = (1.000000000000000000 * output_1.o_28[0]);

	output->output1[28] = (1.000000000000000000 * output_1.o_29[0]);

	output->output1[29] = (1.000000000000000000 * output_1.o_30[0]);

	output->output1[30] = (1.000000000000000000 * output_1.o_31[0]);

	output->output1[31] = (1.000000000000000000 * output_1.o_32[0]);

	output->output1[32] = (1.000000000000000000 * output_1.o_33[0]);

	output->output1[33] = (1.000000000000000000 * output_1.o_34[0]);

	output->output1[34] = (1.000000000000000000 * output_1.o_35[0]);

	output->output1[35] = (1.000000000000000000 * output_1.o_36[0]);

	output->output1[36] = (1.000000000000000000 * output_1.o_37[0]);

	output->output1[37] = (1.000000000000000000 * output_1.o_38[0]);

	output->output1[38] = (1.000000000000000000 * output_1.o_39[0]);

	output->output1[39] = (1.000000000000000000 * output_1.o_40[0]);

	output->output1[40] = (1.000000000000000000 * output_1.o_41[0]);

	output->output1[41] = (1.000000000000000000 * output_1.o_42[0]);

	output->output1[42] = (1.000000000000000000 * output_1.o_43[0]);

	output->output1[43] = (1.000000000000000000 * output_1.o_44[0]);

	output->output1[44] = (1.000000000000000000 * output_1.o_45[0]);

	output->output1[45] = (1.000000000000000000 * output_1.o_46[0]);

	output->output1[46] = (1.000000000000000000 * output_1.o_47[0]);

	output->output1[47] = (1.000000000000000000 * output_1.o_48[0]);

	output->output1[48] = (1.000000000000000000 * output_1.o_49[0]);

	output->output1[49] = (1.000000000000000000 * output_1.o_50[0]);

	output->output1[50] = (1.000000000000000000 * output_1.o_51[0]);

	output->output1[51] = (1.000000000000000000 * output_1.o_52[0]);

	output->output1[52] = (1.000000000000000000 * output_1.o_53[0]);

	output->output1[53] = (1.000000000000000000 * output_1.o_54[0]);

	output->output1[54] = (1.000000000000000000 * output_1.o_55[0]);

	output->output1[55] = (1.000000000000000000 * output_1.o_56[0]);

	output->output1[56] = (1.000000000000000000 * output_1.o_57[0]);

	output->output1[57] = (1.000000000000000000 * output_1.o_58[0]);

	return exitflag;
}